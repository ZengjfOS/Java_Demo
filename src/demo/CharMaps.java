
/*
 * @(#)CharMaps.java     2014/1/16 
 *         1、这个一个Java程序，感谢您花费大量时间阅读本文档；
 *         2、本人知道大家并不喜欢看大量文字描述，但实属无奈，因为我们的沟通只能通过文字；
 *         3、当您在复制、粘贴的时候请注意包名为：practice，文件名为：CharMaps，以防止一些不必要的麻烦；
 *         4、下面这张由字符组成的图是直接由图片生成的，信与不信由您决定，另外可以肯定的是本人绝对不会一个字一个敲这幅图；
 *         5、如果想知道她是如何完成的，请看完CharMaps类前面的全部注释，因为她是工具，有些内容需要了解、素材需要准备；
 *         6、本次注释参考了MyEclipse的注释风格，相对比上次来说注释要规范一些，但由于本人经验、认知水平有限，可能很多地方没有
 *             考虑完全，或者没有解释清楚，请谅解。
虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢
虢虢虢虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢
虢虢虢虢虢一一一一虢虢虢虢一一一一一虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢一一一一一虢虢虢虢虢虢虢虢虢虢虢
虢虢虢虢虢虢一一一虢虢虢一一虢一虢一一虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢一一一一一一一一一一虢虢虢虢虢虢虢虢
虢虢虢虢虢虢一虢一虢虢虢一一一一一一一虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢一一一一一虢虢虢虢一一一一一虢虢虢虢虢虢
虢虢虢虢虢一一虢虢虢虢虢一一虢虢虢一一虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢
虢虢虢虢虢一虢虢虢虢虢虢虢一一一一一虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢一一一虢虢虢虢一一一一虢虢虢虢一一一虢虢虢虢
虢虢虢虢一一虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢一一一一一一一一虢虢虢一一一虢虢虢
虢虢虢虢一一一虢虢虢虢虢一一一一一一一虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢一一虢虢虢一一一一一一一一一一一虢虢一一虢虢虢
虢虢虢虢一虢一一虢虢虢一一虢一一一虢一虢虢虢虢一虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢一一虢虢虢一一一一虢虢虢虢一一一一虢虢虢一一虢虢
虢虢虢虢一虢虢一一虢一一虢虢一一一虢一一虢虢虢一虢虢虢虢虢一一一虢虢一一一一一虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢一一虢虢一一一一虢虢虢虢虢虢一一一一虢虢一一虢虢
虢虢虢一一虢虢虢一一一虢虢虢一一一虢虢一一虢一一虢虢虢虢虢一一一虢一一一一一一一虢虢虢虢虢虢虢一一一虢虢虢虢虢虢一一虢虢一一一虢虢虢一一虢虢虢一一一虢虢一一虢虢
虢虢虢一虢虢虢虢虢虢虢虢一一一一一虢虢虢一一一虢虢虢虢虢虢一一一一一虢虢虢虢一一一虢虢虢虢虢虢一一一虢虢虢虢虢一一虢虢一一一虢虢虢一一一一虢虢虢一一一虢虢一一虢
虢虢一一虢虢虢虢虢虢虢虢一一一一一虢虢虢虢虢虢虢虢虢虢虢虢一一一一虢虢虢虢虢虢一一一虢虢虢虢虢一一一虢虢虢虢虢一一虢虢一一一虢虢一一虢虢一一虢虢一一一虢虢一一虢
虢虢一虢虢虢虢虢虢虢虢虢一虢一一一虢虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢一一一虢虢虢虢虢一一一虢虢虢虢虢一一虢虢一一一虢虢一一虢虢一一虢虢一一一虢虢一一虢
虢虢一虢虢虢虢虢虢虢虢虢一虢一一一虢虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢一一一虢虢虢虢虢一一一虢虢虢虢虢一一虢虢一一一虢虢虢一一一一虢虢虢一一一虢虢一一虢
虢虢一虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢一一一虢虢虢虢虢一一一虢虢虢虢虢虢一一虢虢一一一虢虢虢一一虢虢虢一一一虢虢一一虢虢
虢一一虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢一一一虢虢虢虢虢一一一虢虢虢虢虢虢一一虢虢一一一一虢虢虢虢虢虢一一一一虢虢一一虢虢
虢一虢虢虢虢虢虢虢虢虢虢一一一虢一一虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢一一一虢虢虢虢虢一一一虢虢虢虢虢虢一一虢虢虢一一一一虢虢虢虢一一一一虢虢虢一一虢虢
虢一虢虢一虢虢虢虢虢虢虢一虢虢虢虢一一虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢一一一虢虢虢虢虢一一一虢虢虢虢虢虢虢一一虢虢一一一一一一一一一一一虢虢虢一一虢虢虢
虢虢虢虢一一虢虢虢虢虢一一虢虢虢虢虢一虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢一一一虢虢虢虢虢一一一虢虢虢虢虢虢虢一一一虢虢虢一一一一一一一一虢虢虢一一一虢虢虢
虢虢虢虢虢一一虢虢虢一一虢虢虢虢虢虢一虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢一一一虢虢虢虢虢一一一虢虢虢虢虢虢虢虢一一一虢虢虢虢一一一一虢虢虢虢一一一虢虢虢虢
虢虢虢虢虢虢一一虢虢一虢虢虢虢虢虢虢一一虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢一一一虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢
虢虢虢虢虢虢虢一一一一虢虢虢虢虢虢虢虢一虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢一一一虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢一一一一一虢虢虢虢一一一一一虢虢虢虢虢虢
虢虢虢虢虢虢虢虢一一虢虢虢虢虢虢虢虢虢一虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢一一一虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢虢虢一一一一一一一一一一虢虢虢虢虢虢虢虢
虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢一虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢一一一虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢一一一一虢虢虢虢虢虢虢虢虢虢虢
虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢一虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢
虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢一一一虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢
虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢虢
 */
package demo;

import java.awt.image.BufferedImage;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.imageio.ImageIO;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileNameExtensionFilter;
/**
 *
 * <p>
 * <h4>一、软件声明：</h4><br><ol>
 *         <li>该软件是为了解决TTS无法上图的原因才写出来的，同时感谢您花费宝贵的时间来阅读本文档；<br>
 *         <li>如果您打算使用这个小工具，那么请阅读完这个这整段注释；
 *         <li>如果您只是路过，那么您可以也可以猫一眼 ^_^，不过我相信她不会让您失望的；<br>
 *         <li>该软件已被我命名为CharMaps，在后面的注释中，我说明了命名理由 ^_^；<br>
 *         <li>TTS最小字号是9px阻碍了CharMaps的强大功能，但CharMaps至少能缓解一下我们对图片的向往，希望TTS以后会放宽规则；<br>
 *     
 *         该小工具被我命名为：CharMaps，没有抄袭他人的思路，是根据自己的需求写的，希望她能给您带来乐趣<br>
 * </ol></p>
 *
 * <p>
 * <h4>二、CharMaps由来：</h4><br><ol>
 *         <li>CharMaps制作初衷是因为TTS不能上图，之前上传《动态写轮眼(火影)——Java原创》系列软件时感觉实在不爽，所以自己通过
 *                自己目前的认知水平写了这个CharMaps。<br>
 *         <li>灵感来自硬件传感器——摄像头——的工作原理，有兴趣的朋友可以去找下度娘或者谷哥，听说他们很懂的样子。 ^_^<br>
 *</ol></p>
 *
 * <p>
 * <h4>三、CharMaps命名解析：</h4><br><ol>
 *         <li>Char代表字符，因为她将图片里对一个的像素转换成了字符，为什么是字符而不是字节？原因在于字节宽高比大约是1:2.5，
 *                而字符的宽高大约是1:1，我说的是大约 ^_^；<br>
 *        <li>Map是代表输出的就像每张图片一个映射(map)；<br>
 *        <li>s是因为能同时处理多张图片；<br>
 *        <li>最终组合为CharMaps，很优雅的名字，^_^ ；<br>
 *</ol></p>
 *
 * <p>
 * <h4>四、CharMaps知识预备：</h4><br><ol>
 *         <li>CharMaps采用了具有RGB(red,green,blue)三基色的图片，后缀名为png/PNG/jpeg/jpe/JPEG，但只能处理黑白
 *                 图，原因是黑白图在三基色上是平均分布的，而CharMaps仅是依靠blue分量进行图片处理。<br>
 *         <li>如果您手上没有黑白图，您可以使用我们使用的操作系统自带的The GIMP，该软件自带了离线中文帮助文档，界面挺清爽
 *                 的，您可以通过以下途径打开：应用程序 ——> 图像 ——> The GIMP，如果您不会使用，那就看看帮助文档吧，如果
 *                 您以前使用Photoshop(PS),估计您会有很熟悉的感觉，您以前投资在PS上的时间终于得到了有效回报， ^_^。<br>
 * </ol></p>
 *
 * <p>
 * <h4>五、CharMaps缺陷：</h4><br><ol>
 *         <li>目前只支持黑白图，其他的图不保证效果，主要是写复杂了不利于学习交流，简单并能提供一些思路，并且每个人可以根据
 *                 自己需要进行功能改进或者定制才是沟通学习的王道；<br>
 *         <li>所能转换的图片目前默认支持宽：int charMapsCol = 2000;高：int charMapsRow = 1000;您自己可以修改；<br>
 *         <li>没有提供图片的自动缩放功能，所以不要操作默认支持的宽高，或者你自己修改的宽高；<br>
 *         <li>目前没有发现Bug，不保证您在使用的时候会不会出现Bug，就算遇到了，相信您也能够独立解决,TTS不提供沟通讨论，没办法，
 *                 另外本软件代码行数150左右(不包括注释)，您懂的 ；^_^<br>
 *         <li>如果这个小软件给您带来了不必要的麻烦，本人向您表示歉意。<br>
 * </ol></P>
 *
 * <p>
 * <h4>六、CharMaps操作流程：</h4><br><ol>
 *         <li>准备好一张或者多张后缀是png/PNG/jpeg/jpe/JPEG的文件，运行本程序；<br>
 *         <li>在文件选择框选择要转换的后缀是png/PNG/jpeg/jpe/JPEG的文件，选择完成后点“打开”按钮；不选择就会得到一个空文件；<br>
 *         <li>根据Console提示框中内容找到输出文件，默认是路径/home/soft1/charMaps.txt，您可以自己修改；<br>
 *         <li>用文本编辑器打开，把字号(不是字体)改成2px，看看效果吧。<br>
 * </ol></p>
 *
 * <p>
 * <h4>七、CharMaps工作流程图(非代码分析的朋友可以略过)：</h4><br><ol>
 *             本次注释参考了MyEclipse的注释风格，注释尽量简洁，没有添加过多的额外的注释，以下为main()函数工作流程层次：<br>
 *             <ul>
 *         <li>|--filesSelectInit() //初始化文件选择器，主要用于过滤掉一些后缀不是png/PNG/jpeg/jpe/JPEG的文件，方便选择文件；<br>
 *         <li>|--charMapsInit()     //初始化charMaps数组，并以字符‘虢’填充，主要是笔画多，作为黑色背景好，还有就是字里有老虎 ^_^；<br>
 *         <li>|--ImageProcessing() //图片处理函数，里面包含了如何对图片进行处理的方法；<br>
 *         <ul><li>|--singleImageProcessing() //单张图片处理函数；<br>
 *             <ul><li>|--fileSuffixCheck()   //文件后缀检查，采用了正则表达式，主要是为了防止有些朋友选错；<br>
 *                 <li>|--ImageSizeCheck()       //图片大小检查，主要是因为charMaps大小已由charMapsRow和charMapsCol固定了；<br>
 *                 <li>|--ImageMapToCharMaps() //将图片(Image)映射(map)到charMaps，所有的图片都是以charMaps中心点进行映射
 *                                                 这个步骤中把每张图片的没有内容的边框裁减掉了；<br>
 *             </ul>
 *         </ul>
 *         <li>|--addFrameForCharMaps()//如果转换的图片尺寸没有大于charMaps，那么给图片加个框，您可以通过注释掉这一行
 *                                         看有这个函数和没有这个函数的区别；<br>    
 *         <li>|--fileSave()         //将最终的结果保存起来，路径已经固定，如果您有需要的话可以自己修改里面的路径。<br>
 * </ul></ol></P>
 * @author 曾剑锋<br>
 * @date 2014-1-16<br>
 */
public class CharMaps{
    /** 声明一个文件选择器引用 */
    static JFileChooser jFileChooser = null;
    /**
     *&nbsp &nbsp &nbsp &nbsp
     *      在很多时候，我们在转换成为字符的时候，上、下、左、右总有我们那些我们不需要的一些行，这行不
     *是我们自己需要的，我们还让软件帮我们处理掉吧，默认赋值有那么点讲究，您应该能看懂的,其实跟后面
     *的判断取值有关，初始化值是根据小的取大值，大的取小值的方式，您自己可以看着取。
     *
     */
    static int firstOfUpRow = Integer.MAX_VALUE;
    static int firstOfCol = Integer.MAX_VALUE;
    static int lastOfUpRow = Integer.MIN_VALUE;
    static int lastOfCol = Integer.MIN_VALUE;
    /**
     * charMapsRow用于定义charMaps的行数<br>
     * charMapsCol用于定义charMaps的列数<br>
     */
    static int charMapsRow = 1000;
    static int charMapsCol = 2000;
    static char[][] charMaps = null;

    /** 用于保存您选择的单个或者多个文件路径集合， 初始化为null */
    static File[] filePaths = null;
    
    /** 保存图片的宽、高 */
    static int imageWidth = 0;
    static int imageHeight = 0;
    /**
     * &nbsp &nbsp &nbsp &nbsp
     *       在多张图片处理时候，每张图片处理使用不同的字符区别，charSelectindex用于计数，10个字符循环，
     * 如果一个charMaps同一个位置上字符会被后面的字符替代，如果没有则保持之前的字符<br>
     */
    static int charSelectindex = 0;
    static char[] charSelects = {'一','二','三','四','五','六','七','八','九','十'};
    /** 图像缓冲引用 */
    static BufferedImage bufferedImage = null;
    /**
     * main()函数,完成任务如下：<br><ol>
     *         <li>对文件选择器进行初始化；<br>
     *         <li>对charMaps二维数组进行初始化；<br>
     *         <li>对已选择的图片集进行处理；<br>
     *         <li>由于图片集处理函数对图片有效边界进行了记录，调用addFrameForCharMaps()，添加在上、下、左、右各
     *             添加一个字符的边框，使输出的CharMaps转换出来的图更具视觉效果；<br>
     *         <li>保存转换好的文件；<br>
     *         <li>如果出现异常，给出提示信息。<br></ol>
     */
    public static void main(String[] args) {
        try {
            filesSelectInit();
            charMapsInit();
            ImageProcessing();
            addFrameForCharMaps();
            fileSave();    
        } catch (Exception e) {
            System.out.println("请选择后缀为png/PNG/jpeg/jpe/JPEG的文件");
        }
    }
    /**
     * 图像处理函数，完成任务如下：<br><ol>
     *         <li>判断jFileChooser是否按下了打开；<br>
     *         <li>获取一个或者多个文件，保存于filePaths中；<br>
     *         <li>使用for循环迭代分成单张图片依次处理，调用singleImageProcessing()函数处理；<br>
     *         <li>图片处理完给出提示。<br></ol>
     */
    private static void ImageProcessing() throws IOException {
        //判断是否在文件选择框上点了确定
        if (jFileChooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {
            filePaths = jFileChooser.getSelectedFiles();
            for (File filePath : filePaths) {
                singleImageProcessing(filePath);
            }
            System.out.println("3、完成图像处理");
        }
    }
    /**
     * 单张图片处理函数，完成任务如下：<br><ol>
     *         <li>调用文件后缀检查函数fileSuffixCheck()，防止因操作失误而引发的异常；<br>
     *         <li>调用图片尺寸检查函数ImageSizeCheck()，防止图片尺寸过大，因为没有提供图片缩放功能；<br>
     *         <li>调用图片映射函数ImageMapToCharMaps()，将图片的像素点映射到CharMaps数组中；<br>
     *         <li>如果是多张图片的charSelectindex完成对charSelects数组中10个字符的自动选择。<br></ol>
     *
     * @param filePath    传入filePath进行检查，在返回回来，如果不行就抛弃。<br>
     * @throws IOException<br>
     */
    private static void singleImageProcessing(File filePath) throws IOException {
        filePath = fileSuffixCheck(filePath);
        ImageSizeCheck(filePath);
        ImageMapToCharMaps();
        charSelectindex = charSelectindex++ % 10;
    }
    /**
     * 为charMaps添加边框，完成任务如下：<br>
     * &nbsp &nbsp &nbsp &nbsp
     *         如果有效的图形区域小于charMaps数组大小，在上、下、左、右按条件添加一个字符的边框，使输出的CharMaps转换出来的图更具视觉效果；<br>
     */
    private static void addFrameForCharMaps() {
        firstOfCol = firstOfCol > 0 ? firstOfCol-1 : 0;
        firstOfUpRow = firstOfUpRow > 0 ? firstOfUpRow-1 : 0;
        lastOfCol = lastOfCol < charMapsCol ? lastOfCol+1 : charMapsCol;
        lastOfUpRow = lastOfUpRow < charMapsRow ? lastOfUpRow+1 : charMapsRow;
    }
    /**
     * 图片映射函数，完成任务如下：<br><ol>
     *         <li>双重循环获取图片的宽高；<br>
     *         <li>读出图片对应的坐标的RGB值<br>
     *         <li>判断对应坐标点的RGB是背景还是需要转换，这里之使用了B(blue)的值，判断，这也是为什么目前的
     *             CharMaps只能处理黑白图，当然应该也可以处理白蓝 ^_^<br>
     *         <li>对符合要求的的像素点改变charMaps对应点的字符<br>
     *         <li>对符合要求的像素进行边界检测，主要是完成对图片的边沿检查<br></ol>
     */
    private static void ImageMapToCharMaps() {
        for (int i = 0; i < imageHeight; i++) {
            for (int j = 0; j < imageWidth; j++) {
                int rgb = bufferedImage.getRGB(j, i);
                if ((rgb&0xff)<128 ) {
                    charMaps[charMaps.length/2-imageHeight/2+i][charMaps[0].length/2-imageWidth/2+j] = charSelects[charSelectindex];
                    boundedRangeOfImage(i,j);
                }
            }
        }
    }
    /**
     * 图片边界范围检查函数，完成任务如下：<br>
     * &nbsp &nbsp &nbsp &nbsp
     *         主要是完成检查当前点是否是图片的有效边缘，对图片上、下、左、右有效区域进行查找，为后面保存时裁剪作准备。<br>
     * @param i 当前点的行号
     * @param j 当前点的列号
     */
    private static void boundedRangeOfImage(int i, int j) {
        //记录图形中最上面开始出现图形行号
        if (charMaps.length/2-imageHeight/2+i<firstOfUpRow) {
            firstOfUpRow = charMaps.length/2-imageHeight/2+i;
        }
        //记录图形中最下面开始不再出现图形行号
        if (charMaps.length/2-imageHeight/2+i>lastOfUpRow) {
            lastOfUpRow = charMaps.length/2-imageHeight/2+i;
        }
        //记录图形中一行里面开始出现图形列号
        if (charMaps[0].length/2-imageWidth/2+j<firstOfCol) {
            firstOfCol = charMaps[0].length/2-imageWidth/2+j;
        }
        //记录图形中一行里面开始不再出现图形列号
        if (charMaps[0].length/2-imageWidth/2+j>lastOfCol) {
            lastOfCol = charMaps[0].length/2-imageWidth/2+j;
        }
    }
    /**
     * 图片尺寸检查函数，完成任务如下：<br>
     * &nbsp &nbsp &nbsp &nbsp
     *         主要是完成对图片的尺寸进行检查，不要比默认设置或者自己定制的charMaps数组大。<br>
     */
    private static void ImageSizeCheck(File filePath) throws IOException {
        bufferedImage = ImageIO.read(filePath);
        //得到图片的长宽
        imageWidth = bufferedImage.getWidth();
        imageHeight = bufferedImage.getHeight();
        if ((charMapsRow < imageHeight) || (charMapsCol < imageWidth)) {
            System.out.println("图片宽因该小于2000，高小于1000");
            return ;
        }        
    }
    /**
     * 文件后缀检查函数，完成任务如下：<br>
     * &nbsp &nbsp &nbsp &nbsp
     *         采用正则表达式对文件进行匹配。<br>
     */
    private static File fileSuffixCheck(File filePath) {
        //使用正则表达式来防止选择目前不支持的文件，目前只支持png/PNG/jpeg/jpe/JPEG格式图片
        Pattern pattern = Pattern.compile(".+[.][pPJj][nNpP][eEgGpP][gG]?");
        Matcher matcher = pattern.matcher(filePath.getName());
        if (matcher.matches() == false) {
            return null;
        }
        return filePath;
    }
    /**
     * charMaps初始化函数，Init是初始化的英文单词缩写，完成任务如下：<br>
     * &nbsp &nbsp &nbsp &nbsp
     *         完成对charMaps初始化，并提示完成。<br>
     */
    private static void charMapsInit() {
        charMaps = new char[charMapsRow][charMapsCol];
        //记得需要初始化，否则好像出不来值
        for (int i = 0; i < charMaps.length; i++) {
        	Arrays.fill(charMaps[i], '虢');
        }    
        System.out.println("2、完成charMaps数组初始化");
    }
    /**
     * 文件保存函数，完成任务如下：<br><ol>
     *         <li>设置一个文件保存的路径，这个路径可以自己修改；<br>
     *         <li>创建文件路径下的文件缓冲区；<br>
     *         <li>将charMaps中的字符写好文件中，忽略在上、下、左、右边界之外的部分，只将边界内的字符输出；<br>
     *         <li>每写完一行字符，进行换行；<br>
     *         <li>最后关闭文件缓冲区，如果不关闭，文件缓冲区内的字符可能不会写到文件中，请注意;<br>
     *         <li>提示完成以及提示文件路径。<br><ol>
     */
    private static void fileSave() {
    	JFileChooser jFileChooser = new JFileChooser();
        jFileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);//只能选择目录
        jFileChooser.showOpenDialog(null);
        File saveFilePath = new File(jFileChooser.getSelectedFile().getPath()+"charMaps.txt");
        try {
            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(saveFilePath));
            for (int i = 0; i < charMaps.length; i++) {
                if ((i >= firstOfUpRow) && (i <= lastOfUpRow)) {
                    bufferedWriter.write(charMaps[i], firstOfCol, lastOfCol-firstOfCol+1);
                    bufferedWriter.newLine();
                }
            }
            bufferedWriter.close();
        } catch (IOException e1) {
            e1.printStackTrace();
        }
        System.out.println("4、完成文件保存\n");
        System.out.println("CharMaps已完成完成工作，请到"+saveFilePath.getPath()+"中查看结果 ^_^\n");
    }
    /**
     * 文件选择对话框初始化函数，Init是初始化的英文单词缩写，完成任务如下：<br><ol>
     *         <li>提示欢迎使用CharMaps；<br>
     *         <li>创建文件选择对话框；<br>
     *         <li>创建文件选择过滤器；<br>
     *         <li>将文件选择过滤器添加进入文件对话框，还句话说是：使文件选择过滤器有效；<br>
     *         <li>将文件选择对话框设置为可以多选；<br>
     *         <li>提示完成初始化。<br></ol>
     */
    private static void filesSelectInit() {
        System.out.println("\n\t欢迎使用CharMaps");
        jFileChooser = new JFileChooser();
        FileNameExtensionFilter filter = new FileNameExtensionFilter(
                "Images", "jpg", "png","PNG","JPG","jpe","JPE");
        jFileChooser.setFileFilter(filter);
        jFileChooser.setMultiSelectionEnabled(true);
        System.out.println("1、完成文件选择初始化");
    }
}

